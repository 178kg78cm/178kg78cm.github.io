

CS : 운영체제, 어셈블리어+컴퓨터구조, c언어
리눅스 마스터/정보처리기능사/임베디드기사
ISTQB or CSTS - https://blog.naver.com/onycomite/222327398873

DDRA와 PORTA는 어디에 정의되어 있는가?


임베디드 섹션
1. 왜 리눅스인가.

2. ( ANSI, ISO C ) - GCC 
그리고 MISRA C ★★ (자동차 산업 및 안전 필수 시스템에서 C 코드를 작성할 때 따르는 표준.)

- 전처리 코드
C를 컴파일이 아닌 "전처리"를 한 파일명은 .i 파일로 저장된다.
속성페이지->전처리기->파일로 전처리 아니오:예
전처리 된 파일을 볼 수 있는데 #define으로 정의된 부분이 치환이 된 것을 확인할 수 있다. 이를 통해 매크로 함수가 일반적인 함수의 동작이 아니라 치환의 개념으로 사용되는 것이라고 할 수 있다.
가벼운 함수 구현은 매크로 함수를 사용해보자. 매크로 함수를 사용하게 되면 기존의 함수를 사용할 때 발생하는 오버헤드의 영향이 줄어들기 때문에 효율성이 높아진다. 그러나 전처리 함수는 단순히 치환되는 개념이므로 계산의 우선순위와 관련해서 계산값의 오류가 생길 수 있다. 또한 이러한 오류가 컴파일 오류에서는 발생되지 않으므로 주의해야한다.
  * MAX, MIN, SQUARE, ABS, ARRAY_SIZE, UPPER, LOWER을 사용할 때 적용 시에 적합하다. *

- HAL
상위 레이어와 하위 레이어를 나누는 개념이 매우 중요하다.
하위 레이어가 어떤 구조로 되는지 상위 레이어는 관심이없다. 즉, 어떤 구조인지 몰라도 상위 레이어 개발자는 데이터 값을 얻을 수 있어야한다. 이것을 "HAL" 이라고 한다.

- enum
굳이 외 enum을 사용하는가? 함수 안정이 좋아진다. 자료형의 크기는 enum =  int = char 이기때문에 enum대신 int, char의 데이터 타입을 사용해도 문제없다. 그러나 enum 내부에 정의되어 있는 에러의 범주를 벗어난 입력값이 들어오는 경우도 있으나 이를 막을 수 있다. 이를 "형 안정성"이 좋아진다 라고 표현할 수 있다.

- Dangling Pointer
 외부 함수에서 지역변수의 주소를 리턴할 경우 함수 내부 변수의 메모리는 다시 해제되어 사라진다. 어떠한 동작이 일어날지 예상할 수 없다.

- 구조체
구조체를 사용할 때, 값을 인자로 넘겨줄 때, 포인터로 넘겨주면 편하게 값을 받을 수 있다. 함수 내부에서 동적할당을 사용해서 주소값을 리턴하기 보다는 관리가 편하게 main의 stack에서 선언한 후 이의 주소값을 다시 넘겨주는 방법으로 하는 것이 코드 관리가 수월하다.

구조체를 복사할 때, 깊은 복사와 얕은 복사를 유의한다.

구조체는 메모리에 할당될 때, 가장 큰 데이터 형을 기준으로 구조체 패딩이 되어 메모리가 할당된다. 즉 4,4,1 크기의 데이터가 있다면 가장 큰 데이터형인 4에 맞추어 총 12가 할당된다.  [멤버 크기의 합 + 패딩]
=> 구조체 내부에서는 배열을 많이 사용하지 않는다. 가장 큰 데이터 값을 기준으로 할당되기 때문, 즉 할땡을 쓴느 것이 좋다.

비트 필드 ?? 잘 모르겠음
https://tulip-taker-d50.notion.site/b2895d56df9b4cf1a66f75ff081a1816#7ce01ac91ada45efaa2ba14b6b5d6158


공용체 
모든 멤버가 같은 메모리공간을 공유한다. [가장 큰 멤버 크기]


*과 []도 연산자로 해석되기 때문에 int **arr[2][3] 또한 연산자 우선순위 관점에서 이해하면 편하다.

*(volatile unsigned int *)0xABCD = 0x1234 => memory mapped IO , 임베디드 시스템에서 하드웨어 레지스터나 특정 메모리 주소에 값을 쓰는 데 사용되는 코드이다.
- volatile?
volatile은 값이 외부 요인에 의해 변경될 가능성이 있을 때 사용된다.
주로 하드웨어 레지스터, 멀티스레드 변수, 인터럽트 플래그 등의 상황에서 활용된다
하지만, 동시성 문제를 해결하려면 volatile만으로는 부족하며, 원자적 연산이나 동기화 기법이 필요하다.


주소를 직접 할당하는 방법에 대한 고찰
ASLR 다이나믹 주소 할당
pa = &a;
pa = (int *)0xABCD 이 주소의 실제 위치가 어디가 되는지 모른다.
pa = (int *)0x0019fed8 ASLR 옵션을 끄고, 확인해본 a 주소를 할당하게 된다면 정상적으로 a의 값을 출력할 수 있다.
printf("*pa = %d\n", *pa);

```
	int a = 33;
	int* pa = NULL;
	*(int*)0x0014fcb4 = 99;
	printf("%d", a);
```

그러나 ASLR 즉 동적 주소를 사용하는 이유가 뭘까? 보안 때문이다. 특정 key 값이 고정적으로 할당되는 주소값이 있다면 해당 key값의 메모리 주소을 알아내는 방식으로 해킹이 가능하다.

함수 포인터
C언어는 C++과 다르게 "다형성" 이라는 부분이 정의되지 않는다. 그러나 함수 포인터를 활용한다면 다형성과 유사한 기능을 구현할 수 있다. 
callback 함수를 구현할 수 있다. callback 함수는 다른 함수 내에서 호출되는 함수로, 이벤트 처리, 정렬 알고리즘 등에 활용할 수 있다.

-콜백함수
콜백함수의 정의자체는 어렵지 않으나 어디다 쓰느냐를 이해하기 쉽지않다.
콜러가 콜리를 바로 호출하는 것이 아니라 콜러에게 함수를 등록한 이후에 어떤 조건을 만족하면 등록된 함수를 호출하기 때문에 "콜백"이라고 부른다.

배열 포인터, 콜백함수 등을 활용하는 법을 안다면 C++만큼 강력한 활용이 가능하다.

헤더를 여러번 포함했을 때에는 헤더가드가 동작하여 하나를 막는다.


전처리 파일 ( .i )파일을 통해 컴파일 전 내부 헤더파일 include 나 함수의 호출, define과 같은 전처리 함수의 기능적 흐름을 파악할 수 있다.
이 과정을 통해 헤더파일에서 선언과 정의를 동시에 하는 것에서 내부 흐름이 꼬여 오류가 발생할 수 있음을 이해했다. 이 과정에서 왜 정의를 선언과 다른 파일에서 하는 건지 알 수 있었다. .c 파일에 복수 변수를 정의해 둘 때, 문제가 발생할 수 있다.
.h파일은 컴파일을 하지않고, .c파일은 컴파일을 한다.


Linking error와 Compile error의 차이를 알아보자.

전역변수를 쓰지말아야하는 가장 큰 이유 중 하나는 전역변수의 정의 범위가 너무 넓어 모듈간의 의존성을 떨어뜨릴 수 있기 때문이다.
