---
layout: post
title:  "이진 탐색:백준 1072"
date:   2024-10-28 23:20:29 +0900
categories: [Algorithm]
tags: [Binary search]
---

## 문제 설명
- **입력**: `x`는 총 게임 수, `y`는 이긴 게임 수
- **출력**: **승률이 변하는 최소의 지점**, 없을 경우 -1

## 접근 방법
승률이 변하는 최소의 지점을 출력해야한다. 예를 들어 승률 50%일때, 51%이 되는 최소의 지점을 찾아야한다.
항상 승리한다고 가정하면 x'=x+n, y'=y+n이 되고 이때 n의 최솟값을 찾는 문제이다.

x의 범위가 0~10억이다. 이때 x가 10억 근처의 수임을 고려했을 때, n을 최대 10억으로 정할 수 있다.
조건을 만족하는 n값을 *0<n<1,000,000,000*의 범위에서 **탐색**해야하므로 **이진 탐색**을 사용해서 n값을 찾는다.

[이진 탐색(binary search) 정리글](https://178kg78cm.github.io/algorithm/2024/10/28/binary-search.html)
1. **현재 승률 계산**
    - z = (y * 100) / x로 현재 승률을 계산한다.

2. **이진 탐색 설정**   
    - 목표 승률 이상을 달성하기 위한 최소 게임 횟수를 찾기 위해, 탐색 범위 `[0, 1,000,000,000]`에서 이진 탐색을 수행한다.

3. **이진 탐색 진행**:
    - 중앙값 `n`을 추가로 이긴 게임 횟수라고 가정하고, 새로운 승률 `z_n`을 계산한다.
    - `z_n > z`인 경우, 초기 승률보다 크다. `r = n - 1`로 탐색 범위를 줄인다.
    - `z_n <= z`라면, 초기승률과 동일하다. `l = n + 1`로 탐색 범위를 오른쪽으로 이동한다.
4. **이진탐색 중단 조건**  
    - `l<=r`이 되면 탐색 지점이 뒤바뀐다. 즉 최소 지점을 찾았음을 의미한다.
    - Z가 절대 변하지 않는다면 -1을 출력해야한다. 이 지점을 이진 탐색으로 충분히 탐색한 지점으로 선택해야한다. 29<log (1,000,000,000)<30 이므로 반복이 `최대 30번` 진행되었을 때, 탐색을 중단하는 조건을 추가한다.


## 최종 코드 (C++)

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    cin.tie(NULL);
    ios::sync_with_stdio(false);

    long long x, y;
    cin >> x >> y;

    int z = (y * 100) / x, z_n;  // 초기 승률 계산
    long long l = 0, r = 1000000000, m;
    long long result = -1;
    int max_iter = log2(r) + 1; // 최대 탐색 횟수

    while (l <= r && && max_iter--) {
        m = (r + l) / 2;
        z_n = (y + m) * 100 / (x + m);
        if (z < z_n) { // 승률이 오름
            result = m;
            r = m - 1;
        } else { // 초기 승률에서 변하지 않음.
            l = m + 1;
        }
    }

    cout << result;
    return 0;
}
```