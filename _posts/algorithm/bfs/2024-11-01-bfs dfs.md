---
layout: post
title:  "DFS와 BFS 알고리즘 비교"
date:   2024-11-01 22:15:29 +0900
categories: Algorithm
tags: [DFS, BFS]
---

## DFS (깊이 우선 탐색) 알고리즘 설명

깊이 우선 탐색(DFS)은 그래프 탐색 알고리즘 중 하나로, **한 노드에서 시작하여 갈 수 있는 가장 깊은 곳까지 탐색한 후, 다시 돌아와 다른 경로를 탐색**하는 방식입니다. 이 방식은 재귀 호출이나 스택을 이용하여 구현할 수 있습니다.

- **동작 원리**: 현재 노드에서 연결된 노드를 하나씩 방문하며, 더 이상 방문할 수 있는 노드가 없을 때, 마지막에 방문한 노드로 돌아가 다른 경로를 탐색합니다.
- **구현 방법**: 스택이나 재귀 호출을 사용하여 구현할 수 있습니다.
- **시간 복잡도**: `O(V + E)` (V는 정점의 수, E는 간선의 수)

### DFS 코드 예제

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> graph[1001];
bool visited[1001];

void dfs(int node) {
    visited[node] = true;  // 현재 노드를 방문 처리
    cout << node << " ";   // 방문한 노드 출력

    for (int neighbor : graph[node]) {  // 현재 노드와 연결된 노드들
        if (!visited[neighbor]) {
            dfs(neighbor);  // 방문하지 않은 인접 노드를 재귀적으로 방문
        }
    }
}
```

## BFS (너비 우선 탐색) 알고리즘 설명

너비 우선 탐색(BFS)은 **시작 노드에서 가까운 노드를 먼저 방문하고, 점차 멀리 있는 노드를 탐색**하는 방식입니다. 주로 큐를 사용하여 구현합니다.

- **동작 원리**: 현재 노드의 모든 인접 노드를 먼저 방문한 후, 인접 노드에서 다시 다음 노드를 방문하는 방식으로 진행됩니다.
- **구현 방법**: 큐 자료구조를 사용하여, 현재 노드의 모든 인접 노드를 큐에 넣고, 큐에서 노드를 꺼내며 탐색을 진행합니다.
- **시간 복잡도**: `O(V + E)` (V는 정점의 수, E는 간선의 수)

### BFS 코드 예제

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

vector<int> graph[1001];
bool visited[1001];

void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";  // 방문한 노드 출력

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;  // 방문 처리
            }
        }
    }
}
```

## DFS와 BFS의 차이점

| 특성         | DFS                                | BFS                                |
|--------------|------------------------------------|------------------------------------|
| **탐색 방식** | 깊이 우선으로 탐색, 한 경로의 끝까지 탐색 후 다른 경로 탐색 | 너비 우선으로 탐색, 가까운 노드부터 탐색 |
| **구현 방식** | 스택이나 재귀 호출 사용                  | 큐 사용                               |
| **적용 예시** | 경로 탐색, 순환 탐색, 미로 문제              | 최단 경로 찾기, 레벨 탐색, 최단 거리 문제    |
| **시간 복잡도** | `O(V + E)`                        | `O(V + E)`                        |
| **메모리 사용** | 비교적 적음                            | 더 많이 사용될 수 있음                  |

DFS와 BFS는 각각의 장단점이 있으며, 문제의 성격에 따라 적절한 탐색 방식을 선택하는 것이 중요합니다.


3. 시간복잡도 및 공간복잡도
두 알고리즘 모두 시간복잡도는 
𝑂
(
𝑉
+
𝐸
)
O(V+E)로, 그래프의 모든 노드와 모든 간선을 방문해야 하는 경우에 해당합니다.

BFS 공간복잡도: BFS는 큐에 저장되는 노드 수가 레벨별로 증가할 수 있으므로 공간복잡도가 DFS보다 높을 수 있습니다.
DFS 공간복잡도: DFS는 깊이 우선으로 탐색하므로 스택 또는 재귀 호출의 깊이만큼 메모리를 사용하며, 경로가 깊은 경우 더 많은 메모리가 필요할 수 있습니다.

4. 주로 사용하는 용도
BFS: 최단 경로 탐색과 같은, 가까운 노드부터 점차 멀어지는 방식의 탐색에 유리합니다.
DFS: 모든 경로를 찾거나, 특정 깊이까지 탐색하는 경우에 유리합니다.